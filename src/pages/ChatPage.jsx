import React, { useEffect, useState } from "react";
import {
  clearSession,
  embedArticles,
  fetchArticles,
  fetchSessionHistory,
  fetchSessionId,
  insertEmbeddings,
  searchRelevantArticles,
} from "../api";

const ChatPage = () => {
  const [articles, setArticles] = useState([]);
  const [embeddings, setEmbeddings] = useState([]);

  const [query, setQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [finalAnswer, setFinalAnswer] = useState("");

  const [sessionId, setSessionId] = useState(null); // Store session ID
  const [sessionStarted, setSessionStarted] = useState(false); // Track session status
  const [history, setHistory] = useState([]);

  const [loading, setLoading] = useState(false);

  // Fetch articles when the component mounts
  useEffect(() => {
    if (sessionId) {
      fetchSessionHistory(sessionId).then((history) => {
        setHistory(history);
      });
    }

    const fetchData = async () => {
      try {
        setLoading(true);
        const articlesData = await fetchArticles(); // Fetch articles from the back-end

        setArticles(articlesData);
        const embeddingsData = await embedArticles(articlesData); // Embed articles

        setEmbeddings(embeddingsData);
        await insertEmbeddings(articlesData, embeddingsData); // Insert embeddings into Qdrant
        setLoading(false);
      } catch (error) {
        setLoading(false);
        console.error("Error during API calls:", error);
      }
    };
    fetchData();
  }, [sessionId]);

  // Handle search query and fetch relevant articles
  const handleSearch = async () => {
    try {
      setLoading(true);

      setHistory((prevHistory) => [
        ...prevHistory,
        { user_message: query, bot_response: "" }, // Adding user message to history
      ]);

      const { search_results, final_answer } = await searchRelevantArticles(
        query
      );

      // Format the final_answer before adding it to history
      const formattedAnswer = formatFinalAnswer(final_answer);

      // After getting the bot response, update the history
      setHistory((prevHistory) => [
        ...prevHistory.slice(0, -1), // Remove the temporary user message
        { user_message: query, bot_response: formattedAnswer }, // Add the bot's response
      ]);

      // Update state with search results and final answer
      setSearchResults(search_results);
      setFinalAnswer(final_answer); // Store the final answer generated by Gemini

      setLoading(false);
    } catch (error) {
      setLoading(false);
      console.error("Error during search:", error);
    }
  };

  // Function to initialize a new session
  const startNewSession = async () => {
    try {
      const sessionId = await fetchSessionId(); // Fetch a new session ID
      setSessionId(sessionId); // No need for .json() as Axios returns data directly
      setHistory([]); // Reset chat history
      setSessionStarted(true); // Mark session as started
    } catch (error) {
      console.error("Error starting new session:", error);
    }
  };

  // Function to handle reset (clear session)
  const handleResetSession = async () => {
    if (sessionId) {
      await clearSession(sessionId); // Clear the session on the back-end
      setSessionId(null);
      setHistory([]);
      setSessionStarted(false); // Mark session as not started
    }
  };

  // Parse the search result string to get title and content
  const parseArticle = (article) => {
    const [titlePart, contentPart] = article.split("\nContent:");
    const title = titlePart.replace("Title: ", "");
    const content = contentPart.trim();

    return { title, content };
  };

  // Function to format the final answer
  const formatFinalAnswer = (answer) => {
    // Remove the first line (":")
    const formattedAnswer = answer.split(":")[1].trim(); // Split at the colon and take the part after

    // Split the answer into bullet points based on the asterisks (*)
    const points = formattedAnswer
      .split("*")
      .map((point) => point.trim())
      .filter(Boolean); // Remove empty entries

    return points;
  };

  return (
    <div className="container mx-auto p-4 min-h-screen">
      {/* Show Start New Chat button if session is not started */}
      {!sessionStarted ? (
        <div className="max-w-xl mx-auto bg-white p-6 rounded-lg shadow-lg">
          <h2 className="text-2xl font-semibold text-center mb-4">
            AI Chatbot
          </h2>

          <button
            onClick={startNewSession}
            className="w-full bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 transition duration-300 mb-4"
          >
            Start New Chat
          </button>
        </div>
      ) : (
        <div className="max-w-xl mx-auto bg-white p-6 rounded-lg shadow-lg">
          {/* Chat interface */}
          <h2 className="text-2xl font-semibold text-center mb-4">
            AI Chatbot
          </h2>

          {/* Input Box */}
          <div className="mb-4">
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="Ask a question"
              className="w-full p-2 border rounded-lg"
            />
          </div>

          {/* Search Button */}
          <button
            onClick={handleSearch}
            className="w-full bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 transition duration-300"
          >
            Ask
          </button>

          {loading && (
            <p className="text-center text-gray-500 mt-4">Loading...</p>
          )}

          {/* Display Chat History */}
          <div className="mt-6">
            <h3 className="font-semibold text-xl mb-3">Chat History:</h3>
            <ul>
              {history.map((msg, index) => (
                <li key={index} className="mb-4 p-4 border-b">
                  <div>
                    {/* User message */}
                    <p className="font-semibold text-lg text-blue-600">User:</p>
                    <p className="text-gray-700 mb-2">{msg.user_message}</p>
                  </div>

                  <div>
                    {/* Bot response */}
                    <p className="font-semibold text-lg text-green-600">Bot:</p>
                    <div className="bg-gray-100 p-4 rounded-lg shadow-sm">
                      {msg.bot_response && Array.isArray(msg.bot_response) ? (
                        <ul className="list-disc pl-6">
                          {msg.bot_response.map((point, idx) => (
                            <li key={idx} className="text-gray-800 mb-2">
                              {point}
                            </li>
                          ))}
                        </ul>
                      ) : (
                        <p className="text-gray-700">{msg.bot_response}</p>
                      )}
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          </div>

          {/* Display Final Answer */}
          {/* {finalAnswer && (
            <div className="mt-6">
              <h3 className="font-semibold text-xl mb-3">Final Answer:</h3>
              <p className="text-gray-900 mb-4 font-semibold">{finalAnswer}</p>
            </div>
          )} */}

          {/* Reset Session Button */}
          <button
            onClick={handleResetSession}
            className="w-full bg-red-600 text-white p-2 rounded-lg hover:bg-red-700 transition duration-300 mt-4"
          >
            End Chat
          </button>
        </div>
      )}
    </div>
  );
};

export default ChatPage;
